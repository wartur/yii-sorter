Description of the algorithm ([Русская версия](https://github.com/wartur/yii-sorter/blob/master/ALGORITHM.ru.md))
=================================================================================================================

The algorithm is based on sparse arrays

Sparse array
------------
Let us assume that we have a sparse array with entries indexed in ascending order.
For example, consider an array output equal to 16 [0..16].
```
4
8
12
```

In such an array, you can insert a new record between the two neighboring
just one write operation - assign a new index, the range of which is between
these neighbors. Most inserts a compromise is to get the arithmetic mean
between two adjacent indexes.
```
4
8
10 <<<
12
```

Free Indexes eventually come to an end, and insert the next entry
may be a conflict of indices.
```
4
8
10
<<< I want to insert another record for the position №4
11
12
```

In order to prevent conflicts need to normalize the sparse array,
spreading codes in a way that would generate free space to insert another record
```
2
4
6
8 - this is a new record for the position №4
10
12
```

Next, the whole point of improving the algorithm boils down to a sparse
array to require as little as possible normalization of operations.
This requires frequent operation process, who live according to
different laws of mathematics.

Advantages of this algorithm is that it "pulls" whole blocks
overwriting operation in the case when it is required to insert
an arbitrary place. So when using dense fields sort we would have
to rewrite the whole block of records on interchange. Here is an
example of a different algorithm, the implementation of which is trivial:
```
1 - 1
2 - 2
3 - 3
4 - 4
5 - 5
<<<
6 - 6 *
7 - 7 *	
8 - 8 * >>>
9 - 9
```
* - Asterisk marked records that are updated. From the perspective of SQL is trivial 3 teams that make about the following: 8 assign -8, then do a shift + 1 for 6-7 records with a given before, then 8 assign 6. 10 records it seems nonsense, at 20 thousand work with this in real time is not possible, subject movement over long distances.

Вigression:
> Even in this case, starting from the index requires the middle range,
> i.e. 8. In the example started with the unit for simplicity.

Minus the algorithm works on sparse arrays is that for the algorithm,
we can not fill tightly sort field. The number of entries supported
effectively reduced.
[Read more in How to correctly calculate sort field](https://github.com/wartur/yii-sorter/blob/master/ALGORITHM.md#user-content-Read-more-in-How-to-correctly-calculate-sort-field)

The second problem is the complexity of the implementation of the algorithm

Work at normal distribution
---------------------------
When using the normal distribution is considered that the need
to insert another record between the two border. This means that
the first value to the insert will be equal to (0 + 16) / 2 = 8,
and the second (8 + 16) / 2 = 12, the third (12 + 16) / 2 = 14 and so on ...

Assuming a normal distribution, that is, insertion into arbitrary
locations on the normal distribution does not need to normalize
the audio space, since all records form the next space between
the sparse index.

Meaning the use of the normal distribution in its pure form is not,
as in real life user wishes not accidental. In the above example,
at a constant insertion into the end of the queue after 5-6 iterations,
we will reach between 15..16 degradation and require normalization.
This is one example of linear operations. Such operations require
additional processing by linear laws of mathematics.

Optimization of linear operations
---------------------------------
#### Insert at the beginning / end of the list

As a first example of linear operations take the insert at the
beginning / end of the list, these operations are very frequent in
everyday life. In practice, the new entries are added to the
beginning / end of the list, and then move somewhere else.
Adding to the end of the list is not determined by the normal law.
This is a linear operation.

Take another power array 0..64. EXAMPLE work if we use a standard
insert between two values
```
32
48
56
60
62
63
// Total 6 iterations.
```

As you can see, it did not take so many iterations that have been degraded.
In addition, you can watch at the end of the list is very bad rarefaction array,
and at first too sparse. All this means that for linear insertion end of the list
is required to use a linear function that will generate the next index at
specified intervals. To do this, we define a parameter called
sparse Power (MP) by default. Let's try to make the next insert values with MR = 4
```
32
36
40
44
48
52
56
60
// Total 7 iterations
````

In this time of iterations to get more. We are seeing that a sparse array
is not degraded at the end of the list, and he is able to take the next
entry to any position up to 2 times. Degradation is essentially uniformly
distributed across space.

That's not all. When the use of MR will exit outside the array, you should
use the standard insertion division by 2.
```
... 5 iterations
56
60
62
63
// 10 iterations ...
```
Итого получилось 10 итераций вместо 6-ти изначальных.

#### Перестановка позиций местами
Еще одна частая пользовательская операция это перестановка позиций местами.
Посмотрим пример. В пример добавлены индексы записей, так как теперь придется работать
не с анонимными записями.
```
1 - 32
<<<
2 - 36
3 - 40 >>>
4 - 44
```
При вставке в центр списка приходится использовать стандартный механизм вставки
в разреженное пространство. Попробуем начать переставлять 2 записи местами.
```
// итерация 1
1 - 32
<<<
3 - 34
2 - 36 >>>
4 - 44

// итерация 2
1 - 32
<<<
2 - 33
3 - 34 >>> 
4 - 44

// деградация
```
Мы видим очень высокую скорость деградации при самой частой операции.
Данную операцию необходимо обработать. Обрабатывается она очень просто, мы
просто меняем записи местами
```
// Итерация 0
1 - 32
<<<
2 - 36
3 - 40 >>>
4 - 44

// Итерация 1
1 - 32
<<<
3 - 36
2 - 40 >>>
4 - 44

// Итерация 2
1 - 32
<<<
2 - 36
3 - 40 >>>
4 - 44
// ..... и так до бесконечности
```
В этом случае деградации не происходит вообще. При
желании вы можете сортировать хоть пузырьком.

Процесс нормализации
--------------------
Как было сказано выше алгоритм позволяет оттягивать наступление события при котором
требуется перезаписывать целый блок записей, все равно когда-то это событие настает
С этой проблемой можно сражаться разными способами. Самым простым способом
будет регулярная нормализация разреженного пространства всего массива
через некоторый промежуток времени, в этом случае мы задаем некоторые параметры
прочности разреженного массива и просим пользователя их соблюдать за определенный
промежуток времени.
На нашем примере мы попросим не вставлять в одно и то же место более 2-х раз например
не чаще раза в сутки (ведь при регулярной нормализации произойдет серьезный лаг системы).
Даже если мы берем нормальные настройки, то это будет не более 15 раз в одно место в сутки.
Все равно это очень мало. Что бы не докучать пользователя ограничениями мы должны
уметь разрешать проблемные места автоматически. Для этого была создана нормализация на лету.
Так же есть отдельный тип нормализации - экстремальная нормализация,
как частный случай регулярной нормализации.

#### Нормализация на лету
То есть такая нормализация которая пытается разрешить конфликт в момент его обнаружения
на ограниченном пространстве. Задача сводится к тому, что бы с одной стороны затронуть
как можно меньше записей для уменьшения лага системы, с другой стороны произвести операцию
распределения таким образом, что бы уровень деградации был максимально низок.
Для этого вводится дополнительный параметр алгоритма
Минимальная Локальная Мощность Разрежённости (МЛМР). Этот параметр гарантирует
определенный уровень качества распределения, ниже которого не может опуститься алгоритм,
в следствии чему ему приходится принимать другие решения для разрешения конфликта.
Как используется этот параметр будет объяснено далее.

Теперь перейдем к описанию процесса нормализации на лету. Для этого
нам вновь требуется увеличить мощность разреженного массива. Теперь он такой [0..512].
Далее установим МР = 16 и МЛМР = 4. Кстати обозначим сокращение
Мощность Разреженного Массива (МРМ).

К сожалению, пример получится достаточно громоздким:
```
1 - 256 >>> ... >>>
2 - 272
3 - 288
4 - 304
5 - 320
6 - 336
7 - 352
8 - 368
9 - 384
<<< ... <<<
10 - 400
11 - 416
12 - 432
13 - 448
14 - 464
15 - 480
16 - 496
```

Теперь будем циклически переставлять первую позицию после 9-й пока не наступит конфликт.
Нетрудно подсчитать, что деградация наступит через 4 итерации.
```
5 - 320 >>>
6 - 336!
7 - 352
8 - 368
9 - 384
1 - 392 => *
2 - 396
3 - 398
4 - 399
<<< конфликт!
10 - 400
11 - 416
12 - 432
13 - 448 => *
14 - 464
15 - 480
16 - 496!
```

Теперь начнем процесс нормализации. Для этого требуется выбрать две пограничных записи.
Равное ширине просмотра. В данном случае на 4 позиции. Число 4 берется как
количество сдвигов числа 1 что бы получился МР = 16. То есть 1 << 4 = 16. На самом
деле все настройки правильно хранить в единицах смещения битов, так как потом
удобнее считать некоторые суммы (заметка: если вы посмотрите на низком уровне в реальности
происходит установка последнего "свободного" бита на 1 или на 0 для определения
очередности при вставки новой записи в центр списка).

Далее на этом диапазоне ищется Локальная Мощность Разрежённости (ЛМР).
Для этого требуется взять количество записей в диапазоне между записью 392 и 448. (обозначено "*")
Если перемещаемая запись находится вне диапазона, то её надо добавить к этому количеству.
В нашем случае количество записей 6 + 1 = 7.
Далее мы берем разницу 448-392 = 56 и начинаем искать такой ЛМР, который при
распределении 7-ми записей уместится в этот диапазон. Начнем с максимального,
которые практически всегда не поместится 16(1<<4)*7+16 = 128, 128 <= 56 = false. Ищем дальше.
8(1<<3)*7+8 = 56, 62 <= 56 = false. Ищем дальше. 4(1<<2)*7+4 = 32, 32 <= 56 = true
Отлично, мы нашли новую ЛМР этого диапазона. +16,8,4 которые вы видите в сумме,
это дополнительное зарезервированное место между граничными записями 392 и 448.
Иначе расчет будет происходить впритык, что снижает качество
разрежённости которое получается после нормализации на границах диапазона.

Небольшое отступление 1:
> Если при поиске ЛМР < МЛМР,
> то требуется произвести все действия по поиску заново с удвоенной глубиной просмотра.
> То есть если бы у нас что-то не срослось, то нам бы пришлось брать диапазон
> c 336 до 496 (обозначено "!"). Если снова не нашли, то снова удваиваем просмотр.

Небольшое отступление 2:
> Ширина просмтотра равное 4 выбрано потому что, количество смещений
> это как раз то количество итераций, которое требуется выполнить для получения конфликта.
> Мы берем блок записей с полем сортировки равное с 392 до 448. Одна часть блока является
> нормализированной(ЛМР == МР), вторая часть является деградирующей (ЛМР < МР).
> 
> Кстати, в боевых условиях с высокой степенью вероятности
> обе части будут деградирующими.

Теперь требуется равномерно распределить ЛМР эти записи по этому диапазону, оставив
место для конфликтной записи. Этот алгоритм я объяснять не буду, так как его
можно выполнить по-разному, в результате получается следующий результат.
```
6 - 336
7 - 352
8 - 368
9 - 384
1 - 392
2 - 420 <<<
3 - 424
4 - 428
5 - 432 +++ пространство нормализировано, добавлена новая запись
10 - 436 
11 - 440
12 - 444 <<<
13 - 448
14 - 464
15 - 480
16 - 496
```
Есть еще две специальных ситуации при распределении,
которые можно определить и оптимизировать. Например, если при
поиске одна из границ поиска
оказалось за пределами занятой части массива. Например:
```
1 - 256
<<< ... <<<
2 - 272
3 - 288
4 - 304
5 - 320
6 - 336
7 - 352
8 - 368
9 - 384
10 - 400
11 - 416
12 - 432
13 - 448
14 - 464
15 - 480
16 - 496 >>> ... >>>
```
Результат такой циклической перестановки:
```
1 - 256
<<< конфликт!
13 - 257
14 - 258
15 - 260
16 - 264 => *
2 - 272
3 - 288
4 - 304
5 - 320
6 - 336
7 - 352
8 - 368
9 - 384
10 - 400
11 - 416
12 - 432 >>>
```
То при условии, если у начальной границы разреженного массива до конфликтной
достаточно свободного пространства (264 - 0 = 264 при 5-ти позициях для распределения),
можно провести распределение от одной границы до другой используя параметр МР.
Результат будет таким:
```
1 - 184
12 - 200 +++ пространство нормализировано, добавлена новая запись
13 - 216
14 - 232
15 - 248
16 - 264
2 - 272
3 - 288
4 - 304
5 - 320
6 - 336
7 - 352
8 - 368
9 - 384
10 - 400
11 - 416
12 - 432
```

Вторая ситуация, это когда при поиске 2 границы вышли за текущее пространство.
Это частный случай регулярной нормализации.

#### Регулярная нормализация
То есть такая нормализация, которая пытается восстановить МР по умолчанию на всем
диапазоне значений. Работает предельно просто, берем количество значений, ищем
ЛМР для этого диапазона и распределяем пространство. Если ЛМР < МЛМР, то активируется
экстремальная нормализация

#### Экстремальная нормализация
То есть такая нормализация, которая пытается хоть как-то распределить пространство
и разрешить конфликт, вплоть до полного заполнения мощности разреженного массива.
Для поиска ЛМР используется значение ниже чем МЛМР. По сути, ничем не отличается
от регулярной нормализации, просто это специальный случай, которого происходить
в принципе не должно. Это означает, что алгоритм работает в аварийном режиме
и с огромными лагами.

Как хранить поле сортировки
---------------------------
Поле сортировки это поле INT c уникальным индексом. Уникальность требуется
для обеспечения непротиворечивости информации. Иметь отрицательное значение
требуется для обеспечения возможности перестановки. Так перестановку можно
сделать через отрицательные значения.

Как правильно рассчитывать поле сортировки
------------------------------------------
В алгоритме есть 3 параметра.
МРМ/МР/МЛМР

По умолчанию для 32-битной системы эти параметры равны 30/15/4
(максимальное количество записей с эффективной работой 32768)

Для 64-битной системы эти параметры равны 62/31/6
(максимальное количество записей с эффективной работой 2147483648)

Правильнее всего использовать INT в качестве PK, а BIGINT в качестве поля сортировки.

По настройке все просто. МРМ задает используемый диапазон.
Если вам надо использовать диапазон агрессивнее, то увеличивайте МР. Тогда
операция нормализации будет срабатывать меньше раз. Если вы хотите наоборот иметь
больше значений, то устанавливайте МР меньше, однако из-за этого будет больше
опираций оптимизации.

Заметка по МРМ
Как вы заметили оно тоже определено в битовом смещении. При чем, это битовое
смещение равно 1073741824 то есть половина INT. Это сложилось исторически,
кроме того удобно считать MAX INT без переполнения как INT - 1 + INT.
Эта формула используется для определения верхней границы разреженного массива.
Кроме того, это число используется как первое значение для вставки.

Итого
-----
Алгоритм очень устойчив к разным издевательствам, вроде циклической перестановки
записей в одно и то же место в центре списка, перемещения записи методом пузырька,
циклической вставки в конец списка, имеет уведомления в лог,
которые заведомо сообщает администратору, о том, что алгоритм
в скором времени перейдет на аварийный режим работы. В аварийном режиме
он, хоть и с большими потерями производительности, но продолжит работать, до физического
исчерпания разреженного массива.

Кстати, использование этого алгоритма не отменят возможности использовании простейшего
алгоритма использованного выше, более они могут дополнять друг друга. Так, перемещение
записи на 10 позиций с перезаписью всех десяти блоков не сильно скажется на производительности,
а перемещения на большие расстояния или вставку в центр списка
можно делать с помощью данного алгоритма.


Спасибо
-------
Спасибо что дочитали, надеюсь, было интересно!
