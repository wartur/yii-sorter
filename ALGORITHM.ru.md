Описание алгоритма ([English version](https://github.com/wartur/yii-sorter/blob/master/ALGORITHM.md))
==================

Работа алгоритма основана на разреженных массивах

Разреженный массив
------------------
Допустим, что у нас есть разреженный массив с записями, индексированный по возрастанию.
Для примера, возьмем мощность массива равное 16 [0..16].
```
4
8
12
```

В такой массив можно вставить новую запись между двумя соседними всего за одну
операцию записи - присвоения нового индекса, диапазон которого находится между
этими соседями. Самый компромиссный вариант вставки, это получить среднее
арифметическое между двумя соседними индексами.
```
4
8
10 <<<
12
```

Свободные индексы со временем заканчиваются, и при вставке очередной записи может
произойти конфликт индексов.
```
4
8
10
<<< хочу вставить еще одну запись на позицию №4
11
12
```

Для предотвращения конфликтов требуется нормализовать
разреженный массив, распределяя индексы таким образом,
чтобы образовывалось свободное пространство и вставить очередную запись
```
2
4
6
8 - это новая запись на позиции №4
10
12
```

Далее весь смысл улучшения алгоритма сводится к тому, чтобы разреженный массив
требовал как можно меньше операций нормализации. Для этого требуется обработать частые операции,
которые живут по разным законам математики.

Преимущества данного алгоритма в том, что он "оттягивает" операцию перезаписи
целых блоков, в случае когда требуется вставить в произвольное место. Так при использовании
плотного заполнения поля сортировки нам бы пришлось перезаписывать целый блок записей
при перестановке. Приведем в пример другой алгоритм, реализация которого тривиальна:
```
1 - 1
2 - 2
3 - 3
4 - 4
5 - 5
<<<
6 - 6 *
7 - 7 *	
8 - 8 * >>>
9 - 9
```
* - звездочкой отмечены записи, которые обновятся. С точки зрения SQL
это 3 тривиальных команды которые делают примерно следующие действия:
8 присваиваем -8, далее делаем сдвиг + 1 для записей 6-7 с зада на перед, далее 8 присваиваем 6.
При 10 записях это кажется ерундой, при 20 тысячах работать
с этом в реальном времени будет невозможно при условии перемещения на большие расстояния.

Отступление:
> Даже в этом случае начинать индекс требуется с середины диапазона,
> то есть 8. В примере начат с единицы для простоты.

Минус алгоритма работающего на разреженных массивах в том,
что для использования алгоритма мы не можем плотно заполнять поле сортировки.
Количество  записей поддерживаемых эффективно уменьшается.
Подробнее в разделе [Как правильно рассчитывать поле сортировки](https://github.com/wartur/yii-sorter/blob/master/ALGORITHM.ru.md#user-content-Как-правильно-рассчитывать-поле-сортировки)

Вторая сложность это сложность реализации самого алгоритма

Работа при нормальном распределении
-----------------------------------
При использовании нормального распределения считается, что требуется вставлять
очередную запись между двумя пограничными. Это означает, что первое значение
для вставки будет равно (0 + 16) / 2 = 8, второе (8 + 16) / 2 = 12,
третье (12 + 16) / 2 = 14 и так далее ...

При условии нормального распределения, то есть вставки в произвольные места по
закону нормального распределения не потребуется ни одной нормализации пространства,
так как все очередные записи лягут в разреженные пространства между индексами.

Смысла использования нормального распределения в чистом виде нет, так как в реальной
жизни пожелания пользователя не случайны. В приведенном выше примере при постоянной
вставки в конец очереди уже через 5-6 итераций, мы достигнем деградации
между 15..16 и потребуется нормализация. Это один из примеров линейных операций.
Такие операции требуют дополнительной обработки с помощью линейных законов математики.

Оптимизация линейных операций
-----------------------------
#### Вставка в начало/конец списка

В качестве первого примера линейных операций возьмем вставку в начало/конец списка, эти операции
очень частые в повседневной жизни. На практике новые записи добавляются в начало/конец
списка, а далее перемещаются куда-либо. Добавление в конец списка не определяется нормальным законом.
Это линейная операция.

Возьмем другую мощность массива 0..64. Пример работы в случае, если 
мы используем стандартную вставку между двумя значениями
```
32
48
56
60
62
63
// Итого 6 итераций.
```

Как вы видите, потребовалось не так много итераций, чтобы произошла деградация.
Кроме того можно наблюдать в конце списка очень плохую разрежённость массива, а вначале слишком разреженную.
Все это означает, что для линейной вставки в конец списка требуется использовать
линейную функцию, которая будет генерировать очередной индекс с определенным промежутком.
Для этого зададим параметр, назовем его Мощность Разрежённости(МР) по умолчанию.
Попробуем производить вставку очередных значений с МР = 4
```
32
36
40
44
48
52
56
60
// Итого 7 итераций
````

В этот раз итераций получилось больше. Мы наблюдаем, что разреженный массив
не деградировал в конце списка и он способен принять очередную запись на любую позицию
до 2-х раз. Деградация по сути распределилась по пространству равномерно.

Это еще не все. Когда использование МР приведет к выходу за пределы массива,
следует использовать стандартную вставку с делением на 2.
```
... 5 итераций
56
60
62
63
// 10 итераций ...
```
Итого получилось 10 итераций вместо 6-ти изначальных.

#### Перестановка позиций местами
Еще одна частая пользовательская операция это перестановка позиций местами.
Посмотрим пример. В пример добавлены индексы записей, так как теперь придется работать
не с анонимными записями.
```
1 - 32
<<<
2 - 36
3 - 40 >>>
4 - 44
```
При вставке в центр списка приходится использовать стандартный механизм вставки
в разреженное пространство. Попробуем начать переставлять 2 записи местами.
```
// итерация 1
1 - 32
<<<
3 - 34
2 - 36 >>>
4 - 44

// итерация 2
1 - 32
<<<
2 - 33
3 - 34 >>> 
4 - 44

// деградация
```
Мы видим очень высокую скорость деградации при самой частой операции.
Данную операцию необходимо обработать. Обрабатывается она очень просто, мы
просто меняем записи местами
```
// Итерация 0
1 - 32
<<<
2 - 36
3 - 40 >>>
4 - 44

// Итерация 1
1 - 32
<<<
3 - 36
2 - 40 >>>
4 - 44

// Итерация 2
1 - 32
<<<
2 - 36
3 - 40 >>>
4 - 44
// ..... и так до бесконечности
```
В этом случае деградации не происходит вообще. При
желании вы можете сортировать хоть пузырьком.

Процесс нормализации
--------------------
Как было сказано выше алгоритм позволяет оттягивать наступление события при котором
требуется перезаписывать целый блок записей, все равно когда-то это событие настает
С этой проблемой можно сражаться разными способами. Самым простым способом
будет регулярная нормализация разреженного пространства всего массива
через некоторый промежуток времени, в этом случае мы задаем некоторые параметры
прочности разреженного массива и просим пользователя их соблюдать за определенный
промежуток времени.
На нашем примере мы попросим не вставлять в одно и то же место более 2-х раз например
не чаще раза в сутки (ведь при регулярной нормализации произойдет серьезный лаг системы).
Даже если мы берем нормальные настройки, то это будет не более 15 раз в одно место в сутки.
Все равно это очень мало. Чтобы не докучать пользователя ограничениями мы должны
уметь разрешать проблемные места автоматически. Для этого была создана нормализация на лету.
Так же есть отдельный тип нормализации - экстремальная нормализация,
как частный случай регулярной нормализации.

#### Нормализация на лету
То есть такая нормализация которая пытается разрешить конфликт в момент его обнаружения
на ограниченном пространстве. Задача сводится к тому, чтобы с одной стороны затронуть
как можно меньше записей для уменьшения лага системы, с другой стороны произвести операцию
распределения таким образом, чтобы уровень деградации был максимально низок.
Для этого вводится дополнительный параметр алгоритма
Минимальная Локальная Мощность Разрежённости (МЛМР). Этот параметр гарантирует
определенный уровень качества распределения, ниже которого не может опуститься алгоритм,
в следствии чему ему приходится принимать другие решения для разрешения конфликта.
Как используется этот параметр будет объяснено далее.

Теперь перейдем к описанию процесса нормализации на лету. Для этого
нам вновь требуется увеличить мощность разреженного массива. Теперь он такой [0..512].
Далее установим МР = 16 и МЛМР = 4. Кстати обозначим сокращение
Мощность Разреженного Массива (МРМ).

К сожалению, пример получится достаточно громоздким:
```
1 - 256 >>> ... >>>
2 - 272
3 - 288
4 - 304
5 - 320
6 - 336
7 - 352
8 - 368
9 - 384
<<< ... <<<
10 - 400
11 - 416
12 - 432
13 - 448
14 - 464
15 - 480
16 - 496
```

Теперь будем циклически переставлять первую позицию после 9-й пока не наступит конфликт.
Нетрудно подсчитать, что деградация наступит через 4 итерации.
```
5 - 320 >>>
6 - 336!
7 - 352
8 - 368
9 - 384
1 - 392 => *
2 - 396
3 - 398
4 - 399
<<< конфликт!
10 - 400
11 - 416
12 - 432
13 - 448 => *
14 - 464
15 - 480
16 - 496!
```

Теперь начнем процесс нормализации. Для этого требуется выбрать две пограничных записи.
Равное ширине просмотра. В данном случае на 4 позиции. Число 4 берется как
количество сдвигов числа 1 чтобы получился МР = 16. То есть 1 << 4 = 16. На самом
деле все настройки правильно хранить в единицах смещения битов, так как потом
удобнее считать некоторые суммы (заметка: если вы посмотрите на низком уровне в реальности
происходит установка последнего "свободного" бита на 1 или на 0 для определения
очередности при вставки новой записи в центр списка).

Далее на этом диапазоне ищется Локальная Мощность Разрежённости (ЛМР).
Для этого требуется взять количество записей в диапазоне между записью 392 и 448. (обозначено "*")
Если перемещаемая запись находится вне диапазона, то её надо добавить к этому количеству.
В нашем случае количество записей 6 + 1 = 7.
Далее мы берем разницу 448-392 = 56 и начинаем искать такой ЛМР, который при
распределении 7-ми записей уместится в этот диапазон. Начнем с максимального,
которые практически всегда не поместится 16(1<<4)*7+16 = 128, 128 <= 56 = false. Ищем дальше.
8(1<<3)*7+8 = 56, 62 <= 56 = false. Ищем дальше. 4(1<<2)*7+4 = 32, 32 <= 56 = true
Отлично, мы нашли новую ЛМР этого диапазона. +16,8,4 которые вы видите в сумме,
это дополнительное зарезервированное место между граничными записями 392 и 448.
Иначе расчет будет происходить впритык, что снижает качество
разрежённости которое получается после нормализации на границах диапазона.

Небольшое отступление 1:
> Если при поиске ЛМР < МЛМР,
> то требуется произвести все действия по поиску заново с удвоенной глубиной просмотра.
> То есть если бы у нас что-то не срослось, то нам бы пришлось брать диапазон
> c 336 до 496 (обозначено "!"). Если снова не нашли, то снова удваиваем просмотр.

Небольшое отступление 2:
> Ширина просмотра равное 4 выбрано потому что, количество смещений
> это как раз то количество итераций, которое требуется выполнить для получения конфликта.
> Мы берем блок записей с полем сортировки равное с 392 до 448. Одна часть блока является
> нормализированной(ЛМР == МР), вторая часть является деградирующей (ЛМР < МР).
> 
> Кстати, в боевых условиях с высокой степенью вероятности
> обе части будут деградирующими.

Теперь требуется равномерно распределить ЛМР эти записи по этому диапазону, оставив
место для конфликтной записи. Этот алгоритм я объяснять не буду, так как его
можно выполнить по-разному, в результате получается следующий результат.
```
6 - 336
7 - 352
8 - 368
9 - 384
1 - 392
2 - 420 <<<
3 - 424
4 - 428
5 - 432 +++ пространство нормализовано, добавлена новая запись
10 - 436 
11 - 440
12 - 444 <<<
13 - 448
14 - 464
15 - 480
16 - 496
```
Есть еще две специальных ситуации при распределении,
которые можно определить и оптимизировать. Например, если при
поиске одна из границ поиска
оказалось за пределами занятой части массива. Например:
```
1 - 256
<<< ... <<<
2 - 272
3 - 288
4 - 304
5 - 320
6 - 336
7 - 352
8 - 368
9 - 384
10 - 400
11 - 416
12 - 432
13 - 448
14 - 464
15 - 480
16 - 496 >>> ... >>>
```
Результат такой циклической перестановки:
```
1 - 256
<<< конфликт!
13 - 257
14 - 258
15 - 260
16 - 264 => *
2 - 272
3 - 288
4 - 304
5 - 320
6 - 336
7 - 352
8 - 368
9 - 384
10 - 400
11 - 416
12 - 432 >>>
```
То при условии, если у начальной границы разреженного массива до конфликтной
достаточно свободного пространства (264 - 0 = 264 при 5-ти позициях для распределения),
можно провести распределение от одной границы до другой используя параметр МР.
Результат будет таким:
```
1 - 184
12 - 200 +++ пространство нормализовано, добавлена новая запись
13 - 216
14 - 232
15 - 248
16 - 264
2 - 272
3 - 288
4 - 304
5 - 320
6 - 336
7 - 352
8 - 368
9 - 384
10 - 400
11 - 416
12 - 432
```

Вторая ситуация, это когда при поиске 2 границы вышли за текущее пространство.
Это частный случай регулярной нормализации.

#### Регулярная нормализация
То есть такая нормализация, которая пытается восстановить МР по умолчанию на всем
диапазоне значений. Работает предельно просто, берем количество значений, ищем
ЛМР для этого диапазона и распределяем пространство. Если ЛМР < МЛМР, то активируется
экстремальная нормализация

#### Экстремальная нормализация
То есть такая нормализация, которая пытается хоть как-то распределить пространство
и разрешить конфликт, вплоть до полного заполнения мощности разреженного массива.
Для поиска ЛМР используется значение ниже чем МЛМР. По сути, ничем не отличается
от регулярной нормализации, просто это специальный случай, которого происходить
в принципе не должно. Это означает, что алгоритм работает в аварийном режиме
и с огромными лагами.

Как хранить поле сортировки
---------------------------
Поле сортировки это поле INT c уникальным индексом. Уникальность требуется
для обеспечения непротиворечивости информации. Иметь отрицательное значение
требуется для обеспечения возможности перестановки. Так перестановку можно
сделать через отрицательные значения.

Как правильно рассчитывать поле сортировки
------------------------------------------
В алгоритме есть 3 параметра.
МРМ/МР/МЛМР

По умолчанию для 32-битной системы эти параметры равны 30/15/4
(максимальное количество записей с эффективной работой 32768)

Для 64-битной системы эти параметры равны 62/31/6
(максимальное количество записей с эффективной работой 2147483648)

Правильнее всего использовать INT в качестве PK, а BIGINT в качестве поля сортировки.

По настройке все просто. МРМ задает используемый диапазон.
Если вам надо использовать диапазон агрессивнее, то увеличивайте МР. Тогда
операция нормализации будет срабатывать меньше раз. Если вы хотите наоборот иметь
больше значений, то устанавливайте МР меньше, однако из-за этого будет больше
опираций оптимизации.

Заметка по МРМ
Как вы заметили оно тоже определено в битовом смещении. При чем, это битовое
смещение равно 1073741824 то есть половина INT. Это сложилось исторически,
кроме того удобно считать MAX INT без переполнения как INT - 1 + INT.
Эта формула используется для определения верхней границы разреженного массива.
Кроме того, это число используется как первое значение для вставки.

Итого
-----
Алгоритм очень устойчив к разным издевательствам, вроде циклической перестановки
записей в одно и то же место в центре списка, перемещения записи методом пузырька,
циклической вставки в конец списка, имеет уведомления в лог,
которые заведомо сообщает администратору, о том, что алгоритм
в скором времени перейдет на аварийный режим работы. В аварийном режиме
он, хоть и с большими потерями производительности, но продолжит работать, до физического
исчерпания разреженного массива.

Кстати, использование этого алгоритма не отменят возможности использовании простейшего
алгоритма использованного выше, более они могут дополнять друг друга. Так, перемещение
записи на 10 позиций с перезаписью всех десяти блоков не сильно скажется на производительности,
а перемещения на большие расстояния или вставку в центр списка
можно делать с помощью данного алгоритма.


Спасибо
-------
Спасибо что дочитали, надеюсь, было интересно!
